<?php

namespace Honeygavi\Routing;

use AgaviConfig;
use AgaviContext;
use AgaviExecutionContainer;
use AgaviRoutingCallback;
use InvalidArgumentException;

/**
 * Sets the output type depending on the file extension given in the URL.
 */
class SetOutputTypeRoutingCallback extends AgaviRoutingCallback
{
    /**
     * @var Honeygavi\Controller\HoneybeeAgaviController
     */
    protected $controller = null;

    /**
     * @var array names of available output types
     */
    protected $output_type_names = array();

    /**
     * @param AgaviContext $context
     * @param array $route
     */
    public function initialize(AgaviContext $context, array &$route)
    {
        parent::initialize($context, $route);

        $this->controller = $this->context->getController();
        $this->output_type_names = $this->controller->getOutputTypeNames();
    }

    /**
     * Gets executed when the route of this callback matched.
     *
     * @param array The parameters generated by this route.
     * @param AgaviExecutionContainer The original execution container.
     *
     * @return bool false as routes with this callback should never match.
     *
     * @SuppressWarnings(PHPMD.UnusedFormalParameter)
     */
    public function onMatched(array &$parameters, AgaviExecutionContainer $container)
    {
        $supported_output_types = array();

        // get the matched parameter to match it against the registered file extensions
        $uri_ext = $parameters['ext'];

        // map of output type to file extensions, e.g. 'html' => array('html', 'htm')
        $uri_extensions = $this->getParameter('uri_extensions', array());
        if (!\is_array($uri_extensions)) {
            $uri_extensions = array();
        }

        // check the given output types for types that we really support
        foreach ($uri_extensions as $output_type => $exts) {
            if (!$this->controller->hasOutputType($output_type)) {
                if (AgaviConfig::get('core.debug', false)) {
                    throw new InvalidArgumentException('Output type is not available/configured: ' . $output_type);
                } else {
                    \error_log('[' . __METHOD__ . '] Output type is not available/configured: ' . $output_type);
                }
                continue; // ...we don't want non-existing output types to match later on
            }

            if (\is_string($exts)) {
                $supported_output_types[$output_type] = array($exts);
            } elseif (\is_array($exts)) {
                $supported_output_types[$output_type] = $exts;
            } else {
                throw new InvalidArgumentException(
                    'Invalid parameter value given. Should be a uri file extension string or array of those.'
                );
            }
        }

        $matching_output_type = $this->getMatchingOutputType($uri_ext, $supported_output_types);

        // set the current output type to the matching one
        if ($matching_output_type !== null) {
            $new_output_type = $this->controller->getOutputType($matching_output_type);
            $container->setOutputType($new_output_type);
            return true;
        }

        // file extensions did not match, but we want a default output type to be set
        if ($matching_output_type === null && $this->hasParameter('default_output_type')) {
            $default_output_type = $this->controller->getOutputType($this->getParameter('default_output_type'));
            $container->setOutputType($default_output_type);
            return true;
        }

        return false;
    }

    /**
     * Gets executed when the route of this callback did not match.
     *
     * @param AgaviExecutionContainer The original execution container.
     *
     * @SuppressWarnings(PHPMD.UnusedFormalParameter)
     */
    public function onNotMatched(AgaviExecutionContainer $container)
    {
        return;
    }

    /**
     * Gets executed when the route of this callback is about to be reverse
     * generated into an URL.
     *
     * @param array The default parameters stored in the route.
     * @param array The parameters the user supplied to AgaviRouting::gen().
     * @param array The options the user supplied to AgaviRouting::gen().
     *
     * @return bool false as this route part should not be generated.
     *
     * @SuppressWarnings(PHPMD.UnusedFormalParameter)
     */
    public function onGenerate(array $default_parameters, array &$user_parameters, array &$user_options)
    {
        return true;
    }

    /**
     * @return string output type name of output type that feels responsible for the uri extension
     */
    protected function getMatchingOutputType($uri_extension, $supported_output_types_extensions_map)
    {
        foreach ($supported_output_types_extensions_map as $output_type => $extensions) {
            if (\is_string($extensions) && $extensions === $uri_extension) {
                return $output_type;
            } elseif (\is_array($extensions)) {
                foreach ($extensions as $ext) {
                    if (\is_string($ext) && $ext === $uri_extension) {
                        return $output_type;
                    }
                }
            }
        }

        return null;
    }
}
